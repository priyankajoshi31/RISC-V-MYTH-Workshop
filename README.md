# RISC-V MYTH Workshop- Building a RISC-V core using TL-Verilog
The study of a basic RISC-V ISA and the implementation of a simple RISC-V core with base instruction set have been covered in the 5-day MYTH (Microprocessor for You in Thirty Hours) Workshop on RISC V based CPU Core Design organized by VLSI System Design (VSD) & Redwood EDA. The programming languages employed in the software section are C, Assembly Language, and some pseudo codes. 
The RISC-V CPU core has been designed with the aid of Transaction Level Verilog (TL-Verilog) along with the Makerchip IDE platform. All the information regarding this workshop has been incorporated into this repository as below. Tools used: Spike and Makerchip IDE.

## Table of Contents:

```
* Introduction to RISC-V Worksshop
* Day-1 Instruction Set Architecture & GNU Toolchain.
* Day-2 Application Binary Interface and basic verification flow.
* Day-3 Implementation of Digital logic with TL Verilog and Makerchip.
* Day-4 RISC-V CPU Core Micro-instructions and Implementation.
* Day-5 Pipelining the RISC-V Core Micro-instructions.
* Acknowledgements.
```

## Introduction to RISC V
RISC-V is an open standard instruction set architecture (ISA) based on established reduced instruction set computer (RISC) principles. Unlike most other ISA designs, the RISC-V ISA is provided under open source licenses.Notable features of the RISC-V ISA include a loadâ€“store architecture, bit patterns to simplify the multiplexers in a CPU, IEEE 754 floating-point, and placing most-significant bits at a fixed location to speed sign extension. The instruction set is designed for a wide range of uses. It is variable-width and extensible so that more encoding bits can always be added. It supports three word-widths, 32, 64, and 128 bits, and a variety of subsets.

### Advantage of RISC-V over ARM and X86 :

* RISC-V is open-source, there is no need to pay for the IP.
* RISC-V is far smaller than other commercial ISAs.
* RISC-V has a small standard base ISA, with multiple standard extensions.
* Base and first standard extensions are already frozen. There is no need to worry about major updates.
* Specific functions can be added based on extensions. There are many more extensions are under development, such as Vector.

### Makerchip Platform
Makerchip developed by Redwood EDA is a free online environment for developing high-quality integrated circuits. This platform can code, compile, simulate and debug Verilog designs from a browser and the code, block diagram and waveform are tightly integrated. It supports Transaction-Level Verilog (TL-Verilog), in addition to Verilog and synthesizable SystemVerilog.

![1](https://user-images.githubusercontent.com/73126590/96647739-ddd30080-134b-11eb-897f-038b9f6cb3ff.PNG)

### TL-Verilog
Transaction-Level Verilog (TL-Verilog) is an emerging extension to SystemVerilog that supports a new design methodology, called transaction-level design. In this project design TL-Verilog has been chosed as the HDL of choice with Makerchip IDE. Transaction Level Verilog standard is an extension of Verilog having advantages like simpler syntax, shorter code length and easy pipelining which results in less execution time. The main advantage of TL-Verilog over System Verilog is the code length reduction.

![Capture](https://user-images.githubusercontent.com/73126590/96648011-53d76780-134c-11eb-9288-68a8121a6868.PNG)

Timing abstract can be done in TL-Verilog, which is specified by pipelines in which the sequential elements are generated by tools from the pipelined specification. This allows for easy retiming without the risk of introduction of any functional bugs.




## Day-3: Digital Logic with TL-Verilog and Makerchip

### Contents:
```
1. Combinational logic in TL-Verilog using Makerchip
2. Sequential and pipelined logic
3. Validity
4. Hierarchy
```
An introduction to TL-Verilog with implemention of basic combinational and sequential logic.Finally implementating a sequential cyclic calculator. Makerchip IDE, which is an open source tool developed by Redwood EDA was utilised for this.
TL-Verilog is an extension for System Verilog, moreover it acts as an higher level abstraction for System verilog which makes HDL implementation very easy and error free. Here we deal the design at a transaction level assuming the design as a pipeline, where inputs would be provided and output will be generated at the end of the pipeline.

### Advantages :

* Code reduction , and thus less chances of being bug prone.
* In pipelining ,the flip flops,registers and other staged signals are implied from the context.
* It's very easy to stage different sections without impacting the behaviour of the logic.
* Validity feature which provides easier debugging, cleaner design, automated clock gating and better error checking capabilities.

![3](https://user-images.githubusercontent.com/73126590/96648164-9731d600-134c-11eb-8645-a227b1fa49a2.PNG)

### Lab Exercises:
### 1. Combinational Logic Example: Full Adder
![1](https://user-images.githubusercontent.com/73126590/96648421-f4c62280-134c-11eb-924b-488ce188dd8e.PNG)

### 2. Combinational Calculator
![2](https://user-images.githubusercontent.com/73126590/96648477-06a7c580-134d-11eb-8410-5de23db5b879.PNG)

### 3. Sequential Logic Example: Fibonacci Series
![3](https://user-images.githubusercontent.com/73126590/96648531-1cb58600-134d-11eb-9877-f3b4a6263123.PNG)

### 4. Sequential Calculator
![4](https://user-images.githubusercontent.com/73126590/96648581-2f2fbf80-134d-11eb-8244-34397d536651.PNG)

### 5. A Simple Pipeline through Pythagorous Theorem
![5](https://user-images.githubusercontent.com/73126590/96648637-4373bc80-134d-11eb-91fa-80f56c74252a.PNG)

### 6. Implementation of Pipelining throuh TL-Verilog
![6](https://user-images.githubusercontent.com/73126590/96648672-51c1d880-134d-11eb-9ceb-18c4e3aeadf5.PNG)

### 7. 2-Cycle Calculator
![7](https://user-images.githubusercontent.com/73126590/96648705-61d9b800-134d-11eb-9d0f-a09abd3ae623.PNG)

### 8. Example : Distance Acculmulator
![8](https://user-images.githubusercontent.com/73126590/96648710-64d4a880-134d-11eb-87b4-6cd8fa0280f9.PNG)

### 9. 2-Cycle Calculator with validity
![9](https://user-images.githubusercontent.com/73126590/96648759-7c139600-134d-11eb-8829-8aea651be43b.PNG)

### 10. Calculator with Single Value Memory
![10](https://user-images.githubusercontent.com/73126590/96648769-7ddd5980-134d-11eb-8733-fc19cabf1ae5.PNG)

## Day-4: Basic RISC-V CPU micro-architecture and Implementation

### Contents:
```
1. Microarchitecture and testbench for a simple RISC-V CPU
2. Fetch, decode, and execute logic
3. RISC-V control logic
```

After having a strong basics built in TL-Verilog and digital design, and getting completely familiar with the Makerchip Platform, finally we move to the core aspect of the workshop, i.e. to build a RISC V core. On this day, the instruction set architecture of base integer instructions, next_pc logic, the register file, ALU, branch instructions, etc. and eventually the CPU core was built and tested, using appropriate testbench logic, and assembly code developed on Day 2. The codes can be found here.

### Lab Exercises:
### 1. Next PC Logic
![1](https://user-images.githubusercontent.com/73126590/96648863-a9604400-134d-11eb-8304-27f56991d556.PNG)

### 2. Instruction Fetch Logic
![2](https://user-images.githubusercontent.com/73126590/96648907-bd0baa80-134d-11eb-8e3c-74d334b6d5db.PNG)

### 3. Instruction Decode
![3](https://user-images.githubusercontent.com/73126590/96648949-cdbc2080-134d-11eb-8ef0-9517ae531d88.png)

### 4. Register File Read
![4](https://user-images.githubusercontent.com/73126590/96648956-d0b71100-134d-11eb-82ab-7cf31c67742e.png)

### 5. Arithmetic and Logic Unit(ALU)
![5](https://user-images.githubusercontent.com/73126590/96649024-f217fd00-134d-11eb-8834-10ad765ca3d6.png)

### 6. Register File Write
![6](https://user-images.githubusercontent.com/73126590/96649032-f6441a80-134d-11eb-9b54-f17776ace620.png)

### 7. Branch Instructions
![7](https://user-images.githubusercontent.com/73126590/96649039-f9d7a180-134d-11eb-9ced-f25f494fb6cc.png)

### Final Output: RISCV Core
The final RISC-V CPU core (without pipelining) has been completely implemented.
![8](https://user-images.githubusercontent.com/73126590/96649044-fc39fb80-134d-11eb-9e77-eb62e76aa828.png)


## Day 5: Complete Pipelined RISC-V CPU micro-architecture

### Contents:
 ```
 1. Pipelining the CPU
 2. Load and store instructions and memory
 3. Completing the RISC-V CPU
 4. Wrap-up and future opportunities
``` 

Implementing the pipelining technique and some additonal instructions for the RISC-V core developed on Day-4. The above architecture is pipelined as follows :
* A 3 cycle RISC V pipelined core, with all the base integer instruction sets was developed.
* For Load and store a Data memory element was added with neccessary instruction decoding logic.
* Register Bypass and Squashing techniques were also incorporated to prevent Read followed by write and branchinghazards, arised due to pipelining.
* Testing of the pipeline design was done in same manner with Load and store incorporated in asm code.
* Additionally Incorporation of Jump feature (JAL and JALR instructions) was also done.

The final code can be found here.

### Final Day_5 Output
![1](https://user-images.githubusercontent.com/73126590/96649177-3dcaa680-134e-11eb-8493-95cbbb8a0f5c.png)

### Final Implemention of RISC-V CPU Core
![2](https://user-images.githubusercontent.com/73126590/96649191-428f5a80-134e-11eb-9e1c-a7b45fac1431.png)
